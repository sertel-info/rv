{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///react-maskedinput.min.js","webpack:///webpack/bootstrap 14033b81258fcec2e0e5","webpack:///./src/index.js","webpack:///./~/inputmask-core/lib/index.js","webpack:///external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_2__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","_objectWithoutProperties","obj","keys","target","indexOf","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","writable","setPrototypeOf","__proto__","isUndo","e","ctrlKey","metaKey","keyCode","shiftKey","KEYCODE_Y","KEYCODE_Z","isRedo","getSelection","el","start","end","rangeEl","clone","undefined","selectionStart","selectionEnd","focus","createTextRange","duplicate","moveToBookmark","document","selection","createRange","getBookmark","setEndPoint","text","length","setSelection","setSelectionRange","collapse","moveStart","moveEnd","select","__WEBPACK_IMPORTED_MODULE_0_react__","__WEBPACK_IMPORTED_MODULE_0_react___default","__WEBPACK_IMPORTED_MODULE_1_inputmask_core__","__WEBPACK_IMPORTED_MODULE_1_inputmask_core___default","_extends","assign","arguments","source","key","MaskedInput","_React$Component","props","_this","_onChange","bind","_onKeyDown","_onPaste","_onKeyPress","componentWillMount","options","pattern","mask","formatCharacters","placeholderChar","a","componentWillReceiveProps","nextProps","getValue","emptyValue","setPattern","getRawValue","setValue","componentWillUpdate","nextState","_updatePattern","componentDidUpdate","prevProps","_updateInputSelection","input","_updateMaskSelection","maskValue","sizeDiff","backspace","_getDisplayValue","onChange","preventDefault","undo","redo","altKey","data","paste","clipboardData","getData","setTimeout","_keyPressPropName","navigator","userAgent","match","_getEventHandlers","_ref","onKeyDown","onPaste","blur","render","_this2","ref","r","maxLength","eventHandlers","_props","_props$size","size","_props$placeholder","placeholder","_props2","cleanedProps","inputProps","createElement","Component","defaultProps","extend","dest","src","copy","mergeFormatCharacters","merged","DEFAULT_FORMAT_CHARACTERS","chars","char","Pattern","isRevealingMask","DEFAULT_PLACEHOLDER_CHAR","firstEditableIndex","lastEditableIndex","_editableIndices","_parse","InputMask","Error","DIGIT_RE","LETTER_RE","ALPHANNUMERIC_RE","*","validate","test","1","A","transform","toUpperCase","#","sourceChars","split","patternIndex","push","formatValue","valueBuffer","Array","valueIndex","isEditableIndex","isValidAtIndex","index","format","selectionBefore","valueBefore","inputIndex","_historyIndex","_history","splice","_lastOp","_lastSelection","lastOp","initialState","slice","charAt","substring","historyItem","startUndo","pop","join","_resetHistory","rawValue"],"mappings":"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","file":"react-maskedinput.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"MaskedInput\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"MaskedInput\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"MaskedInput\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"MaskedInput\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 3);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_inputmask_core__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_inputmask_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_inputmask_core__);\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\nvar KEYCODE_Z = 90;\nvar KEYCODE_Y = 89;\n\nfunction isUndo(e) {\n  return (e.ctrlKey || e.metaKey) && e.keyCode === (e.shiftKey ? KEYCODE_Y : KEYCODE_Z);\n}\n\nfunction isRedo(e) {\n  return (e.ctrlKey || e.metaKey) && e.keyCode === (e.shiftKey ? KEYCODE_Z : KEYCODE_Y);\n}\n\nfunction getSelection(el) {\n  var start, end, rangeEl, clone;\n\n  if (el.selectionStart !== undefined) {\n    start = el.selectionStart;\n    end = el.selectionEnd;\n  } else {\n    try {\n      el.focus();\n      rangeEl = el.createTextRange();\n      clone = rangeEl.duplicate();\n\n      rangeEl.moveToBookmark(document.selection.createRange().getBookmark());\n      clone.setEndPoint('EndToStart', rangeEl);\n\n      start = clone.text.length;\n      end = start + rangeEl.text.length;\n    } catch (e) {/* not focused or not visible */}\n  }\n\n  return { start: start, end: end };\n}\n\nfunction setSelection(el, selection) {\n  var rangeEl;\n\n  try {\n    if (el.selectionStart !== undefined) {\n      el.focus();\n      el.setSelectionRange(selection.start, selection.end);\n    } else {\n      el.focus();\n      rangeEl = el.createTextRange();\n      rangeEl.collapse(true);\n      rangeEl.moveStart('character', selection.start);\n      rangeEl.moveEnd('character', selection.end - selection.start);\n      rangeEl.select();\n    }\n  } catch (e) {/* not focused or not visible */}\n}\n\nvar MaskedInput = function (_React$Component) {\n  _inherits(MaskedInput, _React$Component);\n\n  function MaskedInput(props) {\n    _classCallCheck(this, MaskedInput);\n\n    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));\n\n    _this._onChange = _this._onChange.bind(_this);\n    _this._onKeyDown = _this._onKeyDown.bind(_this);\n    _this._onPaste = _this._onPaste.bind(_this);\n    _this._onKeyPress = _this._onKeyPress.bind(_this);\n    return _this;\n  }\n\n  MaskedInput.prototype.componentWillMount = function componentWillMount() {\n    var options = {\n      pattern: this.props.mask,\n      value: this.props.value,\n      formatCharacters: this.props.formatCharacters\n    };\n    if (this.props.placeholderChar) {\n      options.placeholderChar = this.props.placeholderChar;\n    }\n    this.mask = new __WEBPACK_IMPORTED_MODULE_1_inputmask_core___default.a(options);\n  };\n\n  MaskedInput.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    if (this.props.mask !== nextProps.mask && this.props.value !== nextProps.mask) {\n      // if we get a new value and a new mask at the same time\n      // check if the mask.value is still the initial value\n      // - if so use the nextProps value\n      // - otherwise the `this.mask` has a value for us (most likely from paste action)\n      if (this.mask.getValue() === this.mask.emptyValue) {\n        this.mask.setPattern(nextProps.mask, { value: nextProps.value });\n      } else {\n        this.mask.setPattern(nextProps.mask, { value: this.mask.getRawValue() });\n      }\n    } else if (this.props.mask !== nextProps.mask) {\n      this.mask.setPattern(nextProps.mask, { value: this.mask.getRawValue() });\n    } else if (this.props.value !== nextProps.value) {\n      this.mask.setValue(nextProps.value);\n    }\n  };\n\n  MaskedInput.prototype.componentWillUpdate = function componentWillUpdate(nextProps, nextState) {\n    if (nextProps.mask !== this.props.mask) {\n      this._updatePattern(nextProps);\n    }\n  };\n\n  MaskedInput.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {\n    if (prevProps.mask !== this.props.mask && this.mask.selection.start) {\n      this._updateInputSelection();\n    }\n  };\n\n  MaskedInput.prototype._updatePattern = function _updatePattern(props) {\n    this.mask.setPattern(props.mask, {\n      value: this.mask.getRawValue(),\n      selection: getSelection(this.input)\n    });\n  };\n\n  MaskedInput.prototype._updateMaskSelection = function _updateMaskSelection() {\n    this.mask.selection = getSelection(this.input);\n  };\n\n  MaskedInput.prototype._updateInputSelection = function _updateInputSelection() {\n    setSelection(this.input, this.mask.selection);\n  };\n\n  MaskedInput.prototype._onChange = function _onChange(e) {\n    // console.log('onChange', JSON.stringify(getSelection(this.input)), e.target.value)\n\n    var maskValue = this.mask.getValue();\n    if (e.target.value !== maskValue) {\n      // Cut or delete operations will have shortened the value\n      if (e.target.value.length < maskValue.length) {\n        var sizeDiff = maskValue.length - e.target.value.length;\n        this._updateMaskSelection();\n        this.mask.selection.end = this.mask.selection.start + sizeDiff;\n        this.mask.backspace();\n      }\n      var value = this._getDisplayValue();\n      e.target.value = value;\n      if (value) {\n        this._updateInputSelection();\n      }\n    }\n    if (this.props.onChange) {\n      this.props.onChange(e);\n    }\n  };\n\n  MaskedInput.prototype._onKeyDown = function _onKeyDown(e) {\n    // console.log('onKeyDown', JSON.stringify(getSelection(this.input)), e.key, e.target.value)\n\n    if (isUndo(e)) {\n      e.preventDefault();\n      if (this.mask.undo()) {\n        e.target.value = this._getDisplayValue();\n        this._updateInputSelection();\n        if (this.props.onChange) {\n          this.props.onChange(e);\n        }\n      }\n      return;\n    } else if (isRedo(e)) {\n      e.preventDefault();\n      if (this.mask.redo()) {\n        e.target.value = this._getDisplayValue();\n        this._updateInputSelection();\n        if (this.props.onChange) {\n          this.props.onChange(e);\n        }\n      }\n      return;\n    }\n\n    if (e.key === 'Backspace') {\n      e.preventDefault();\n      this._updateMaskSelection();\n      if (this.mask.backspace()) {\n        var value = this._getDisplayValue();\n        e.target.value = value;\n        if (value) {\n          this._updateInputSelection();\n        }\n        if (this.props.onChange) {\n          this.props.onChange(e);\n        }\n      }\n    }\n  };\n\n  MaskedInput.prototype._onKeyPress = function _onKeyPress(e) {\n    // console.log('onKeyPress', JSON.stringify(getSelection(this.input)), e.key, e.target.value)\n\n    // Ignore modified key presses\n    // Ignore enter key to allow form submission\n    if (e.metaKey || e.altKey || e.ctrlKey || e.key === 'Enter') {\n      return;\n    }\n\n    e.preventDefault();\n    this._updateMaskSelection();\n    if (this.mask.input(e.key || e.data)) {\n      e.target.value = this.mask.getValue();\n      this._updateInputSelection();\n      if (this.props.onChange) {\n        this.props.onChange(e);\n      }\n    }\n  };\n\n  MaskedInput.prototype._onPaste = function _onPaste(e) {\n    // console.log('onPaste', JSON.stringify(getSelection(this.input)), e.clipboardData.getData('Text'), e.target.value)\n\n    e.preventDefault();\n    this._updateMaskSelection();\n    // getData value needed for IE also works in FF & Chrome\n    if (this.mask.paste(e.clipboardData.getData('Text'))) {\n      e.target.value = this.mask.getValue();\n      // Timeout needed for IE\n      setTimeout(this._updateInputSelection, 0);\n      if (this.props.onChange) {\n        this.props.onChange(e);\n      }\n    }\n  };\n\n  MaskedInput.prototype._getDisplayValue = function _getDisplayValue() {\n    var value = this.mask.getValue();\n    return value === this.mask.emptyValue ? '' : value;\n  };\n\n  MaskedInput.prototype._keyPressPropName = function _keyPressPropName() {\n    if (typeof navigator !== 'undefined') {\n      return navigator.userAgent.match(/Android/i) ? 'onBeforeInput' : 'onKeyPress';\n    }\n    return 'onKeyPress';\n  };\n\n  MaskedInput.prototype._getEventHandlers = function _getEventHandlers() {\n    var _ref;\n\n    return _ref = {\n      onChange: this._onChange,\n      onKeyDown: this._onKeyDown,\n      onPaste: this._onPaste\n    }, _ref[this._keyPressPropName()] = this._onKeyPress, _ref;\n  };\n\n  MaskedInput.prototype.focus = function focus() {\n    this.input.focus();\n  };\n\n  MaskedInput.prototype.blur = function blur() {\n    this.input.blur();\n  };\n\n  MaskedInput.prototype.render = function render() {\n    var _this2 = this;\n\n    var ref = function ref(r) {\n      _this2.input = r;\n    };\n    var maxLength = this.mask.pattern.length;\n    var value = this._getDisplayValue();\n    var eventHandlers = this._getEventHandlers();\n    var _props = this.props,\n        _props$size = _props.size,\n        size = _props$size === undefined ? maxLength : _props$size,\n        _props$placeholder = _props.placeholder,\n        placeholder = _props$placeholder === undefined ? this.mask.emptyValue : _props$placeholder;\n\n    var _props2 = this.props,\n        placeholderChar = _props2.placeholderChar,\n        formatCharacters = _props2.formatCharacters,\n        cleanedProps = _objectWithoutProperties(_props2, ['placeholderChar', 'formatCharacters']); // eslint-disable-line\n\n\n    var inputProps = _extends({}, cleanedProps, eventHandlers, { ref: ref, maxLength: maxLength, value: value, size: size, placeholder: placeholder });\n    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('input', inputProps);\n  };\n\n  return MaskedInput;\n}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);\n\nMaskedInput.defaultProps = {\n  value: ''\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (MaskedInput);\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction extend(dest, src) {\n  if (src) {\n    var props = Object.keys(src)\n    for (var i = 0, l = props.length; i < l ; i++) {\n      dest[props[i]] = src[props[i]]\n    }\n  }\n  return dest\n}\n\nfunction copy(obj) {\n  return extend({}, obj)\n}\n\n/**\n * Merge an object defining format characters into the defaults.\n * Passing null/undefined for en existing format character removes it.\n * Passing a definition for an existing format character overrides it.\n * @param {?Object} formatCharacters.\n */\nfunction mergeFormatCharacters(formatCharacters) {\n  var merged = copy(DEFAULT_FORMAT_CHARACTERS)\n  if (formatCharacters) {\n    var chars = Object.keys(formatCharacters)\n    for (var i = 0, l = chars.length; i < l ; i++) {\n      var char = chars[i]\n      if (formatCharacters[char] == null) {\n        delete merged[char]\n      }\n      else {\n        merged[char] = formatCharacters[char]\n      }\n    }\n  }\n  return merged\n}\n\nvar ESCAPE_CHAR = '\\\\'\n\nvar DIGIT_RE = /^\\d$/\nvar LETTER_RE = /^[A-Za-z]$/\nvar ALPHANNUMERIC_RE = /^[\\dA-Za-z]$/\n\nvar DEFAULT_PLACEHOLDER_CHAR = '_'\nvar DEFAULT_FORMAT_CHARACTERS = {\n  '*': {\n    validate: function(char) { return ALPHANNUMERIC_RE.test(char) }\n  },\n  '1': {\n    validate: function(char) { return DIGIT_RE.test(char) }\n  },\n  'a': {\n    validate: function(char) { return LETTER_RE.test(char) }\n  },\n  'A': {\n    validate: function(char) { return LETTER_RE.test(char) },\n    transform: function(char) { return char.toUpperCase() }\n  },\n  '#': {\n    validate: function(char) { return ALPHANNUMERIC_RE.test(char) },\n    transform: function(char) { return char.toUpperCase() }\n  }\n}\n\n/**\n * @param {string} source\n * @patam {?Object} formatCharacters\n */\nfunction Pattern(source, formatCharacters, placeholderChar, isRevealingMask) {\n  if (!(this instanceof Pattern)) {\n    return new Pattern(source, formatCharacters, placeholderChar)\n  }\n\n  /** Placeholder character */\n  this.placeholderChar = placeholderChar || DEFAULT_PLACEHOLDER_CHAR\n  /** Format character definitions. */\n  this.formatCharacters = formatCharacters || DEFAULT_FORMAT_CHARACTERS\n  /** Pattern definition string with escape characters. */\n  this.source = source\n  /** Pattern characters after escape characters have been processed. */\n  this.pattern = []\n  /** Length of the pattern after escape characters have been processed. */\n  this.length = 0\n  /** Index of the first editable character. */\n  this.firstEditableIndex = null\n  /** Index of the last editable character. */\n  this.lastEditableIndex = null\n  /** Lookup for indices of editable characters in the pattern. */\n  this._editableIndices = {}\n  /** If true, only the pattern before the last valid value character shows. */\n  this.isRevealingMask = isRevealingMask || false\n\n  this._parse()\n}\n\nPattern.prototype._parse = function parse() {\n  var sourceChars = this.source.split('')\n  var patternIndex = 0\n  var pattern = []\n\n  for (var i = 0, l = sourceChars.length; i < l; i++) {\n    var char = sourceChars[i]\n    if (char === ESCAPE_CHAR) {\n      if (i === l - 1) {\n        throw new Error('InputMask: pattern ends with a raw ' + ESCAPE_CHAR)\n      }\n      char = sourceChars[++i]\n    }\n    else if (char in this.formatCharacters) {\n      if (this.firstEditableIndex === null) {\n        this.firstEditableIndex = patternIndex\n      }\n      this.lastEditableIndex = patternIndex\n      this._editableIndices[patternIndex] = true\n    }\n\n    pattern.push(char)\n    patternIndex++\n  }\n\n  if (this.firstEditableIndex === null) {\n    throw new Error(\n      'InputMask: pattern \"' + this.source + '\" does not contain any editable characters.'\n    )\n  }\n\n  this.pattern = pattern\n  this.length = pattern.length\n}\n\n/**\n * @param {Array<string>} value\n * @return {Array<string>}\n */\nPattern.prototype.formatValue = function format(value) {\n  var valueBuffer = new Array(this.length)\n  var valueIndex = 0\n\n  for (var i = 0, l = this.length; i < l ; i++) {\n    if (this.isEditableIndex(i)) {\n      if (this.isRevealingMask &&\n          value.length <= valueIndex &&\n          !this.isValidAtIndex(value[valueIndex], i)) {\n        break\n      }\n      valueBuffer[i] = (value.length > valueIndex && this.isValidAtIndex(value[valueIndex], i)\n                        ? this.transform(value[valueIndex], i)\n                        : this.placeholderChar)\n      valueIndex++\n    }\n    else {\n      valueBuffer[i] = this.pattern[i]\n      // Also allow the value to contain static values from the pattern by\n      // advancing its index.\n      if (value.length > valueIndex && value[valueIndex] === this.pattern[i]) {\n        valueIndex++\n      }\n    }\n  }\n\n  return valueBuffer\n}\n\n/**\n * @param {number} index\n * @return {boolean}\n */\nPattern.prototype.isEditableIndex = function isEditableIndex(index) {\n  return !!this._editableIndices[index]\n}\n\n/**\n * @param {string} char\n * @param {number} index\n * @return {boolean}\n */\nPattern.prototype.isValidAtIndex = function isValidAtIndex(char, index) {\n  return this.formatCharacters[this.pattern[index]].validate(char)\n}\n\nPattern.prototype.transform = function transform(char, index) {\n  var format = this.formatCharacters[this.pattern[index]]\n  return typeof format.transform == 'function' ? format.transform(char) : char\n}\n\nfunction InputMask(options) {\n  if (!(this instanceof InputMask)) { return new InputMask(options) }\n  options = extend({\n    formatCharacters: null,\n    pattern: null,\n    isRevealingMask: false,\n    placeholderChar: DEFAULT_PLACEHOLDER_CHAR,\n    selection: {start: 0, end: 0},\n    value: ''\n  }, options)\n\n  if (options.pattern == null) {\n    throw new Error('InputMask: you must provide a pattern.')\n  }\n\n  if (typeof options.placeholderChar !== 'string' || options.placeholderChar.length > 1) {\n    throw new Error('InputMask: placeholderChar should be a single character or an empty string.')\n  }\n\n  this.placeholderChar = options.placeholderChar\n  this.formatCharacters = mergeFormatCharacters(options.formatCharacters)\n  this.setPattern(options.pattern, {\n    value: options.value,\n    selection: options.selection,\n    isRevealingMask: options.isRevealingMask\n  })\n}\n\n// Editing\n\n/**\n * Applies a single character of input based on the current selection.\n * @param {string} char\n * @return {boolean} true if a change has been made to value or selection as a\n *   result of the input, false otherwise.\n */\nInputMask.prototype.input = function input(char) {\n  // Ignore additional input if the cursor's at the end of the pattern\n  if (this.selection.start === this.selection.end &&\n      this.selection.start === this.pattern.length) {\n    return false\n  }\n\n  var selectionBefore = copy(this.selection)\n  var valueBefore = this.getValue()\n\n  var inputIndex = this.selection.start\n\n  // If the cursor or selection is prior to the first editable character, make\n  // sure any input given is applied to it.\n  if (inputIndex < this.pattern.firstEditableIndex) {\n    inputIndex = this.pattern.firstEditableIndex\n  }\n\n  // Bail out or add the character to input\n  if (this.pattern.isEditableIndex(inputIndex)) {\n    if (!this.pattern.isValidAtIndex(char, inputIndex)) {\n      return false\n    }\n    this.value[inputIndex] = this.pattern.transform(char, inputIndex)\n  }\n\n  // If multiple characters were selected, blank the remainder out based on the\n  // pattern.\n  var end = this.selection.end - 1\n  while (end > inputIndex) {\n    if (this.pattern.isEditableIndex(end)) {\n      this.value[end] = this.placeholderChar\n    }\n    end--\n  }\n\n  // Advance the cursor to the next character\n  this.selection.start = this.selection.end = inputIndex + 1\n\n  // Skip over any subsequent static characters\n  while (this.pattern.length > this.selection.start &&\n         !this.pattern.isEditableIndex(this.selection.start)) {\n    this.selection.start++\n    this.selection.end++\n  }\n\n  // History\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n    this._historyIndex = null\n  }\n  if (this._lastOp !== 'input' ||\n      selectionBefore.start !== selectionBefore.end ||\n      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n  }\n  this._lastOp = 'input'\n  this._lastSelection = copy(this.selection)\n\n  return true\n}\n\n/**\n * Attempts to delete from the value based on the current cursor position or\n * selection.\n * @return {boolean} true if the value or selection changed as the result of\n *   backspacing, false otherwise.\n */\nInputMask.prototype.backspace = function backspace() {\n  // If the cursor is at the start there's nothing to do\n  if (this.selection.start === 0 && this.selection.end === 0) {\n    return false\n  }\n\n  var selectionBefore = copy(this.selection)\n  var valueBefore = this.getValue()\n\n  // No range selected - work on the character preceding the cursor\n  if (this.selection.start === this.selection.end) {\n    if (this.pattern.isEditableIndex(this.selection.start - 1)) {\n      this.value[this.selection.start - 1] = this.placeholderChar\n    }\n    this.selection.start--\n    this.selection.end--\n  }\n  // Range selected - delete characters and leave the cursor at the start of the selection\n  else {\n    var end = this.selection.end - 1\n    while (end >= this.selection.start) {\n      if (this.pattern.isEditableIndex(end)) {\n        this.value[end] = this.placeholderChar\n      }\n      end--\n    }\n    this.selection.end = this.selection.start\n  }\n\n  // History\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n  }\n  if (this._lastOp !== 'backspace' ||\n      selectionBefore.start !== selectionBefore.end ||\n      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n  }\n  this._lastOp = 'backspace'\n  this._lastSelection = copy(this.selection)\n\n  return true\n}\n\n/**\n * Attempts to paste a string of input at the current cursor position or over\n * the top of the current selection.\n * Invalid content at any position will cause the paste to be rejected, and it\n * may contain static parts of the mask's pattern.\n * @param {string} input\n * @return {boolean} true if the paste was successful, false otherwise.\n */\nInputMask.prototype.paste = function paste(input) {\n  // This is necessary because we're just calling input() with each character\n  // and rolling back if any were invalid, rather than checking up-front.\n  var initialState = {\n    value: this.value.slice(),\n    selection: copy(this.selection),\n    _lastOp: this._lastOp,\n    _history: this._history.slice(),\n    _historyIndex: this._historyIndex,\n    _lastSelection: copy(this._lastSelection)\n  }\n\n  // If there are static characters at the start of the pattern and the cursor\n  // or selection is within them, the static characters must match for a valid\n  // paste.\n  if (this.selection.start < this.pattern.firstEditableIndex) {\n    for (var i = 0, l = this.pattern.firstEditableIndex - this.selection.start; i < l; i++) {\n      if (input.charAt(i) !== this.pattern.pattern[i]) {\n        return false\n      }\n    }\n\n    // Continue as if the selection and input started from the editable part of\n    // the pattern.\n    input = input.substring(this.pattern.firstEditableIndex - this.selection.start)\n    this.selection.start = this.pattern.firstEditableIndex\n  }\n\n  for (i = 0, l = input.length;\n       i < l && this.selection.start <= this.pattern.lastEditableIndex;\n       i++) {\n    var valid = this.input(input.charAt(i))\n    // Allow static parts of the pattern to appear in pasted input - they will\n    // already have been stepped over by input(), so verify that the value\n    // deemed invalid by input() was the expected static character.\n    if (!valid) {\n      if (this.selection.start > 0) {\n        // XXX This only allows for one static character to be skipped\n        var patternIndex = this.selection.start - 1\n        if (!this.pattern.isEditableIndex(patternIndex) &&\n            input.charAt(i) === this.pattern.pattern[patternIndex]) {\n          continue\n        }\n      }\n      extend(this, initialState)\n      return false\n    }\n  }\n\n  return true\n}\n\n// History\n\nInputMask.prototype.undo = function undo() {\n  // If there is no history, or nothing more on the history stack, we can't undo\n  if (this._history.length === 0 || this._historyIndex === 0) {\n    return false\n  }\n\n  var historyItem\n  if (this._historyIndex == null) {\n    // Not currently undoing, set up the initial history index\n    this._historyIndex = this._history.length - 1\n    historyItem = this._history[this._historyIndex]\n    // Add a new history entry if anything has changed since the last one, so we\n    // can redo back to the initial state we started undoing from.\n    var value = this.getValue()\n    if (historyItem.value !== value ||\n        historyItem.selection.start !== this.selection.start ||\n        historyItem.selection.end !== this.selection.end) {\n      this._history.push({value: value, selection: copy(this.selection), lastOp: this._lastOp, startUndo: true})\n    }\n  }\n  else {\n    historyItem = this._history[--this._historyIndex]\n  }\n\n  this.value = historyItem.value.split('')\n  this.selection = historyItem.selection\n  this._lastOp = historyItem.lastOp\n  return true\n}\n\nInputMask.prototype.redo = function redo() {\n  if (this._history.length === 0 || this._historyIndex == null) {\n    return false\n  }\n  var historyItem = this._history[++this._historyIndex]\n  // If this is the last history item, we're done redoing\n  if (this._historyIndex === this._history.length - 1) {\n    this._historyIndex = null\n    // If the last history item was only added to start undoing, remove it\n    if (historyItem.startUndo) {\n      this._history.pop()\n    }\n  }\n  this.value = historyItem.value.split('')\n  this.selection = historyItem.selection\n  this._lastOp = historyItem.lastOp\n  return true\n}\n\n// Getters & setters\n\nInputMask.prototype.setPattern = function setPattern(pattern, options) {\n  options = extend({\n    selection: {start: 0, end: 0},\n    value: ''\n  }, options)\n  this.pattern = new Pattern(pattern, this.formatCharacters, this.placeholderChar, options.isRevealingMask)\n  this.setValue(options.value)\n  this.emptyValue = this.pattern.formatValue([]).join('')\n  this.selection = options.selection\n  this._resetHistory()\n}\n\nInputMask.prototype.setSelection = function setSelection(selection) {\n  this.selection = copy(selection)\n  if (this.selection.start === this.selection.end) {\n    if (this.selection.start < this.pattern.firstEditableIndex) {\n      this.selection.start = this.selection.end = this.pattern.firstEditableIndex\n      return true\n    }\n    // Set selection to the first editable, non-placeholder character before the selection\n    // OR to the beginning of the pattern\n    var index = this.selection.start\n    while (index >= this.pattern.firstEditableIndex) {\n      if (this.pattern.isEditableIndex(index - 1) &&\n          this.value[index - 1] !== this.placeholderChar ||\n          index === this.pattern.firstEditableIndex) {\n        this.selection.start = this.selection.end = index\n        break\n      }\n      index--\n    }\n    return true\n  }\n  return false\n}\n\nInputMask.prototype.setValue = function setValue(value) {\n  if (value == null) {\n    value = ''\n  }\n  this.value = this.pattern.formatValue(value.split(''))\n}\n\nInputMask.prototype.getValue = function getValue() {\n  return this.value.join('')\n}\n\nInputMask.prototype.getRawValue = function getRawValue() {\n  var rawValue = []\n  for (var i = 0; i < this.value.length; i++) {\n    if (this.pattern._editableIndices[i] === true) {\n      rawValue.push(this.value[i])\n    }\n  }\n  return rawValue.join('')\n}\n\nInputMask.prototype._resetHistory = function _resetHistory() {\n  this._history = []\n  this._historyIndex = null\n  this._lastOp = null\n  this._lastSelection = copy(this.selection)\n}\n\nInputMask.Pattern = Pattern\n\nmodule.exports = InputMask\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(0);\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// react-maskedinput.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 14033b81258fcec2e0e5","import React from 'react'\nimport PropTypes from 'prop-types'\nimport InputMask from 'inputmask-core'\n\nvar KEYCODE_Z = 90\nvar KEYCODE_Y = 89\n\nfunction isUndo(e) {\n  return (e.ctrlKey || e.metaKey) && e.keyCode === (e.shiftKey ? KEYCODE_Y : KEYCODE_Z)\n}\n\nfunction isRedo(e) {\n  return (e.ctrlKey || e.metaKey) && e.keyCode === (e.shiftKey ? KEYCODE_Z : KEYCODE_Y)\n}\n\nfunction getSelection (el) {\n  var start, end, rangeEl, clone\n\n  if (el.selectionStart !== undefined) {\n    start = el.selectionStart\n    end = el.selectionEnd\n  }\n  else {\n    try {\n      el.focus()\n      rangeEl = el.createTextRange()\n      clone = rangeEl.duplicate()\n\n      rangeEl.moveToBookmark(document.selection.createRange().getBookmark())\n      clone.setEndPoint('EndToStart', rangeEl)\n\n      start = clone.text.length\n      end = start + rangeEl.text.length\n    }\n    catch (e) { /* not focused or not visible */ }\n  }\n\n  return { start, end }\n}\n\nfunction setSelection(el, selection) {\n  var rangeEl\n\n  try {\n    if (el.selectionStart !== undefined) {\n      el.focus()\n      el.setSelectionRange(selection.start, selection.end)\n    }\n    else {\n      el.focus()\n      rangeEl = el.createTextRange()\n      rangeEl.collapse(true)\n      rangeEl.moveStart('character', selection.start)\n      rangeEl.moveEnd('character', selection.end - selection.start)\n      rangeEl.select()\n    }\n  }\n  catch (e) { /* not focused or not visible */ }\n}\n\nclass MaskedInput extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this._onChange = this._onChange.bind(this)\n    this._onKeyDown = this._onKeyDown.bind(this)\n    this._onPaste = this._onPaste.bind(this)\n    this._onKeyPress = this._onKeyPress.bind(this)\n  }\n\n  componentWillMount() {\n    var options = {\n      pattern: this.props.mask,\n      value: this.props.value,\n      formatCharacters: this.props.formatCharacters\n    }\n    if (this.props.placeholderChar) {\n      options.placeholderChar = this.props.placeholderChar\n    }\n    this.mask = new InputMask(options)\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (this.props.mask !== nextProps.mask && this.props.value !== nextProps.mask) {\n      // if we get a new value and a new mask at the same time\n      // check if the mask.value is still the initial value\n      // - if so use the nextProps value\n      // - otherwise the `this.mask` has a value for us (most likely from paste action)\n      if (this.mask.getValue() === this.mask.emptyValue) {\n        this.mask.setPattern(nextProps.mask, {value: nextProps.value})\n      }\n      else {\n        this.mask.setPattern(nextProps.mask, {value: this.mask.getRawValue()})\n      }\n    }\n    else if (this.props.mask !== nextProps.mask) {\n      this.mask.setPattern(nextProps.mask, {value: this.mask.getRawValue()})\n    }\n    else if (this.props.value !== nextProps.value) {\n      this.mask.setValue(nextProps.value)\n    }\n  }\n\n  componentWillUpdate(nextProps, nextState) {\n    if (nextProps.mask !== this.props.mask) {\n      this._updatePattern(nextProps)\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.mask !== this.props.mask && this.mask.selection.start) {\n      this._updateInputSelection()\n    }\n  }\n\n  _updatePattern(props) {\n    this.mask.setPattern(props.mask, {\n      value: this.mask.getRawValue(),\n      selection: getSelection(this.input)\n    })\n  }\n\n  _updateMaskSelection() {\n    this.mask.selection = getSelection(this.input)\n  }\n\n  _updateInputSelection() {\n    setSelection(this.input, this.mask.selection)\n  }\n\n  _onChange(e) {\n    // console.log('onChange', JSON.stringify(getSelection(this.input)), e.target.value)\n\n    var maskValue = this.mask.getValue()\n    if (e.target.value !== maskValue) {\n      // Cut or delete operations will have shortened the value\n      if (e.target.value.length < maskValue.length) {\n        var sizeDiff = maskValue.length - e.target.value.length\n        this._updateMaskSelection()\n        this.mask.selection.end = this.mask.selection.start + sizeDiff\n        this.mask.backspace()\n      }\n      var value = this._getDisplayValue()\n      e.target.value = value\n      if (value) {\n        this._updateInputSelection()\n      }\n    }\n    if (this.props.onChange) {\n      this.props.onChange(e)\n    }\n  }\n\n  _onKeyDown(e) {\n    // console.log('onKeyDown', JSON.stringify(getSelection(this.input)), e.key, e.target.value)\n\n    if (isUndo(e)) {\n      e.preventDefault()\n      if (this.mask.undo()) {\n        e.target.value = this._getDisplayValue()\n        this._updateInputSelection()\n        if (this.props.onChange) {\n          this.props.onChange(e)\n        }\n      }\n      return\n    }\n    else if (isRedo(e)) {\n      e.preventDefault()\n      if (this.mask.redo()) {\n        e.target.value = this._getDisplayValue()\n        this._updateInputSelection()\n        if (this.props.onChange) {\n          this.props.onChange(e)\n        }\n      }\n      return\n    }\n\n    if (e.key === 'Backspace') {\n      e.preventDefault()\n      this._updateMaskSelection()\n      if (this.mask.backspace()) {\n        var value = this._getDisplayValue()\n        e.target.value = value\n        if (value) {\n          this._updateInputSelection()\n        }\n        if (this.props.onChange) {\n          this.props.onChange(e)\n        }\n      }\n    }\n  }\n\n  _onKeyPress(e) {\n    // console.log('onKeyPress', JSON.stringify(getSelection(this.input)), e.key, e.target.value)\n\n    // Ignore modified key presses\n    // Ignore enter key to allow form submission\n    if (e.metaKey || e.altKey || e.ctrlKey || e.key === 'Enter') { return }\n\n    e.preventDefault()\n    this._updateMaskSelection()\n    if (this.mask.input((e.key || e.data))) {\n      e.target.value = this.mask.getValue()\n      this._updateInputSelection()\n      if (this.props.onChange) {\n        this.props.onChange(e)\n      }\n    }\n  }\n\n  _onPaste(e) {\n    // console.log('onPaste', JSON.stringify(getSelection(this.input)), e.clipboardData.getData('Text'), e.target.value)\n\n    e.preventDefault()\n    this._updateMaskSelection()\n    // getData value needed for IE also works in FF & Chrome\n    if (this.mask.paste(e.clipboardData.getData('Text'))) {\n      e.target.value = this.mask.getValue()\n      // Timeout needed for IE\n      setTimeout(this._updateInputSelection, 0)\n      if (this.props.onChange) {\n        this.props.onChange(e)\n      }\n    }\n  }\n\n  _getDisplayValue() {\n    var value = this.mask.getValue()\n    return value === this.mask.emptyValue ? '' : value\n  }\n\n  _keyPressPropName() {\n    if (typeof navigator !== 'undefined') {\n      return navigator.userAgent.match(/Android/i)\n      ? 'onBeforeInput'\n      : 'onKeyPress'\n    }\n    return 'onKeyPress'\n  }\n\n  _getEventHandlers() {\n    return {\n      onChange: this._onChange,\n      onKeyDown: this._onKeyDown,\n      onPaste: this._onPaste,\n      [this._keyPressPropName()]: this._onKeyPress\n    }\n  }\n\n  focus() {\n    this.input.focus()\n  }\n\n  blur() {\n    this.input.blur()\n  }\n\n  render() {\n    var ref = r => { this.input = r }\n    var maxLength = this.mask.pattern.length\n    var value = this._getDisplayValue()\n    var eventHandlers = this._getEventHandlers()\n    var { size = maxLength, placeholder = this.mask.emptyValue } = this.props\n\n    var { placeholderChar, formatCharacters, ...cleanedProps } = this.props // eslint-disable-line\n    var inputProps = { ...cleanedProps, ...eventHandlers, ref, maxLength, value, size, placeholder }\n    return <input {...inputProps} />\n  }\n}\n\nMaskedInput.propTypes = {\n  mask: PropTypes.string.isRequired,\n\n  formatCharacters: PropTypes.object,\n  placeholderChar: PropTypes.string\n}\n\nMaskedInput.defaultProps = {\n  value: ''\n}\n\nexport default MaskedInput\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","'use strict'\n\nfunction extend(dest, src) {\n  if (src) {\n    var props = Object.keys(src)\n    for (var i = 0, l = props.length; i < l ; i++) {\n      dest[props[i]] = src[props[i]]\n    }\n  }\n  return dest\n}\n\nfunction copy(obj) {\n  return extend({}, obj)\n}\n\n/**\n * Merge an object defining format characters into the defaults.\n * Passing null/undefined for en existing format character removes it.\n * Passing a definition for an existing format character overrides it.\n * @param {?Object} formatCharacters.\n */\nfunction mergeFormatCharacters(formatCharacters) {\n  var merged = copy(DEFAULT_FORMAT_CHARACTERS)\n  if (formatCharacters) {\n    var chars = Object.keys(formatCharacters)\n    for (var i = 0, l = chars.length; i < l ; i++) {\n      var char = chars[i]\n      if (formatCharacters[char] == null) {\n        delete merged[char]\n      }\n      else {\n        merged[char] = formatCharacters[char]\n      }\n    }\n  }\n  return merged\n}\n\nvar ESCAPE_CHAR = '\\\\'\n\nvar DIGIT_RE = /^\\d$/\nvar LETTER_RE = /^[A-Za-z]$/\nvar ALPHANNUMERIC_RE = /^[\\dA-Za-z]$/\n\nvar DEFAULT_PLACEHOLDER_CHAR = '_'\nvar DEFAULT_FORMAT_CHARACTERS = {\n  '*': {\n    validate: function(char) { return ALPHANNUMERIC_RE.test(char) }\n  },\n  '1': {\n    validate: function(char) { return DIGIT_RE.test(char) }\n  },\n  'a': {\n    validate: function(char) { return LETTER_RE.test(char) }\n  },\n  'A': {\n    validate: function(char) { return LETTER_RE.test(char) },\n    transform: function(char) { return char.toUpperCase() }\n  },\n  '#': {\n    validate: function(char) { return ALPHANNUMERIC_RE.test(char) },\n    transform: function(char) { return char.toUpperCase() }\n  }\n}\n\n/**\n * @param {string} source\n * @patam {?Object} formatCharacters\n */\nfunction Pattern(source, formatCharacters, placeholderChar, isRevealingMask) {\n  if (!(this instanceof Pattern)) {\n    return new Pattern(source, formatCharacters, placeholderChar)\n  }\n\n  /** Placeholder character */\n  this.placeholderChar = placeholderChar || DEFAULT_PLACEHOLDER_CHAR\n  /** Format character definitions. */\n  this.formatCharacters = formatCharacters || DEFAULT_FORMAT_CHARACTERS\n  /** Pattern definition string with escape characters. */\n  this.source = source\n  /** Pattern characters after escape characters have been processed. */\n  this.pattern = []\n  /** Length of the pattern after escape characters have been processed. */\n  this.length = 0\n  /** Index of the first editable character. */\n  this.firstEditableIndex = null\n  /** Index of the last editable character. */\n  this.lastEditableIndex = null\n  /** Lookup for indices of editable characters in the pattern. */\n  this._editableIndices = {}\n  /** If true, only the pattern before the last valid value character shows. */\n  this.isRevealingMask = isRevealingMask || false\n\n  this._parse()\n}\n\nPattern.prototype._parse = function parse() {\n  var sourceChars = this.source.split('')\n  var patternIndex = 0\n  var pattern = []\n\n  for (var i = 0, l = sourceChars.length; i < l; i++) {\n    var char = sourceChars[i]\n    if (char === ESCAPE_CHAR) {\n      if (i === l - 1) {\n        throw new Error('InputMask: pattern ends with a raw ' + ESCAPE_CHAR)\n      }\n      char = sourceChars[++i]\n    }\n    else if (char in this.formatCharacters) {\n      if (this.firstEditableIndex === null) {\n        this.firstEditableIndex = patternIndex\n      }\n      this.lastEditableIndex = patternIndex\n      this._editableIndices[patternIndex] = true\n    }\n\n    pattern.push(char)\n    patternIndex++\n  }\n\n  if (this.firstEditableIndex === null) {\n    throw new Error(\n      'InputMask: pattern \"' + this.source + '\" does not contain any editable characters.'\n    )\n  }\n\n  this.pattern = pattern\n  this.length = pattern.length\n}\n\n/**\n * @param {Array<string>} value\n * @return {Array<string>}\n */\nPattern.prototype.formatValue = function format(value) {\n  var valueBuffer = new Array(this.length)\n  var valueIndex = 0\n\n  for (var i = 0, l = this.length; i < l ; i++) {\n    if (this.isEditableIndex(i)) {\n      if (this.isRevealingMask &&\n          value.length <= valueIndex &&\n          !this.isValidAtIndex(value[valueIndex], i)) {\n        break\n      }\n      valueBuffer[i] = (value.length > valueIndex && this.isValidAtIndex(value[valueIndex], i)\n                        ? this.transform(value[valueIndex], i)\n                        : this.placeholderChar)\n      valueIndex++\n    }\n    else {\n      valueBuffer[i] = this.pattern[i]\n      // Also allow the value to contain static values from the pattern by\n      // advancing its index.\n      if (value.length > valueIndex && value[valueIndex] === this.pattern[i]) {\n        valueIndex++\n      }\n    }\n  }\n\n  return valueBuffer\n}\n\n/**\n * @param {number} index\n * @return {boolean}\n */\nPattern.prototype.isEditableIndex = function isEditableIndex(index) {\n  return !!this._editableIndices[index]\n}\n\n/**\n * @param {string} char\n * @param {number} index\n * @return {boolean}\n */\nPattern.prototype.isValidAtIndex = function isValidAtIndex(char, index) {\n  return this.formatCharacters[this.pattern[index]].validate(char)\n}\n\nPattern.prototype.transform = function transform(char, index) {\n  var format = this.formatCharacters[this.pattern[index]]\n  return typeof format.transform == 'function' ? format.transform(char) : char\n}\n\nfunction InputMask(options) {\n  if (!(this instanceof InputMask)) { return new InputMask(options) }\n  options = extend({\n    formatCharacters: null,\n    pattern: null,\n    isRevealingMask: false,\n    placeholderChar: DEFAULT_PLACEHOLDER_CHAR,\n    selection: {start: 0, end: 0},\n    value: ''\n  }, options)\n\n  if (options.pattern == null) {\n    throw new Error('InputMask: you must provide a pattern.')\n  }\n\n  if (typeof options.placeholderChar !== 'string' || options.placeholderChar.length > 1) {\n    throw new Error('InputMask: placeholderChar should be a single character or an empty string.')\n  }\n\n  this.placeholderChar = options.placeholderChar\n  this.formatCharacters = mergeFormatCharacters(options.formatCharacters)\n  this.setPattern(options.pattern, {\n    value: options.value,\n    selection: options.selection,\n    isRevealingMask: options.isRevealingMask\n  })\n}\n\n// Editing\n\n/**\n * Applies a single character of input based on the current selection.\n * @param {string} char\n * @return {boolean} true if a change has been made to value or selection as a\n *   result of the input, false otherwise.\n */\nInputMask.prototype.input = function input(char) {\n  // Ignore additional input if the cursor's at the end of the pattern\n  if (this.selection.start === this.selection.end &&\n      this.selection.start === this.pattern.length) {\n    return false\n  }\n\n  var selectionBefore = copy(this.selection)\n  var valueBefore = this.getValue()\n\n  var inputIndex = this.selection.start\n\n  // If the cursor or selection is prior to the first editable character, make\n  // sure any input given is applied to it.\n  if (inputIndex < this.pattern.firstEditableIndex) {\n    inputIndex = this.pattern.firstEditableIndex\n  }\n\n  // Bail out or add the character to input\n  if (this.pattern.isEditableIndex(inputIndex)) {\n    if (!this.pattern.isValidAtIndex(char, inputIndex)) {\n      return false\n    }\n    this.value[inputIndex] = this.pattern.transform(char, inputIndex)\n  }\n\n  // If multiple characters were selected, blank the remainder out based on the\n  // pattern.\n  var end = this.selection.end - 1\n  while (end > inputIndex) {\n    if (this.pattern.isEditableIndex(end)) {\n      this.value[end] = this.placeholderChar\n    }\n    end--\n  }\n\n  // Advance the cursor to the next character\n  this.selection.start = this.selection.end = inputIndex + 1\n\n  // Skip over any subsequent static characters\n  while (this.pattern.length > this.selection.start &&\n         !this.pattern.isEditableIndex(this.selection.start)) {\n    this.selection.start++\n    this.selection.end++\n  }\n\n  // History\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n    this._historyIndex = null\n  }\n  if (this._lastOp !== 'input' ||\n      selectionBefore.start !== selectionBefore.end ||\n      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n  }\n  this._lastOp = 'input'\n  this._lastSelection = copy(this.selection)\n\n  return true\n}\n\n/**\n * Attempts to delete from the value based on the current cursor position or\n * selection.\n * @return {boolean} true if the value or selection changed as the result of\n *   backspacing, false otherwise.\n */\nInputMask.prototype.backspace = function backspace() {\n  // If the cursor is at the start there's nothing to do\n  if (this.selection.start === 0 && this.selection.end === 0) {\n    return false\n  }\n\n  var selectionBefore = copy(this.selection)\n  var valueBefore = this.getValue()\n\n  // No range selected - work on the character preceding the cursor\n  if (this.selection.start === this.selection.end) {\n    if (this.pattern.isEditableIndex(this.selection.start - 1)) {\n      this.value[this.selection.start - 1] = this.placeholderChar\n    }\n    this.selection.start--\n    this.selection.end--\n  }\n  // Range selected - delete characters and leave the cursor at the start of the selection\n  else {\n    var end = this.selection.end - 1\n    while (end >= this.selection.start) {\n      if (this.pattern.isEditableIndex(end)) {\n        this.value[end] = this.placeholderChar\n      }\n      end--\n    }\n    this.selection.end = this.selection.start\n  }\n\n  // History\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n  }\n  if (this._lastOp !== 'backspace' ||\n      selectionBefore.start !== selectionBefore.end ||\n      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n  }\n  this._lastOp = 'backspace'\n  this._lastSelection = copy(this.selection)\n\n  return true\n}\n\n/**\n * Attempts to paste a string of input at the current cursor position or over\n * the top of the current selection.\n * Invalid content at any position will cause the paste to be rejected, and it\n * may contain static parts of the mask's pattern.\n * @param {string} input\n * @return {boolean} true if the paste was successful, false otherwise.\n */\nInputMask.prototype.paste = function paste(input) {\n  // This is necessary because we're just calling input() with each character\n  // and rolling back if any were invalid, rather than checking up-front.\n  var initialState = {\n    value: this.value.slice(),\n    selection: copy(this.selection),\n    _lastOp: this._lastOp,\n    _history: this._history.slice(),\n    _historyIndex: this._historyIndex,\n    _lastSelection: copy(this._lastSelection)\n  }\n\n  // If there are static characters at the start of the pattern and the cursor\n  // or selection is within them, the static characters must match for a valid\n  // paste.\n  if (this.selection.start < this.pattern.firstEditableIndex) {\n    for (var i = 0, l = this.pattern.firstEditableIndex - this.selection.start; i < l; i++) {\n      if (input.charAt(i) !== this.pattern.pattern[i]) {\n        return false\n      }\n    }\n\n    // Continue as if the selection and input started from the editable part of\n    // the pattern.\n    input = input.substring(this.pattern.firstEditableIndex - this.selection.start)\n    this.selection.start = this.pattern.firstEditableIndex\n  }\n\n  for (i = 0, l = input.length;\n       i < l && this.selection.start <= this.pattern.lastEditableIndex;\n       i++) {\n    var valid = this.input(input.charAt(i))\n    // Allow static parts of the pattern to appear in pasted input - they will\n    // already have been stepped over by input(), so verify that the value\n    // deemed invalid by input() was the expected static character.\n    if (!valid) {\n      if (this.selection.start > 0) {\n        // XXX This only allows for one static character to be skipped\n        var patternIndex = this.selection.start - 1\n        if (!this.pattern.isEditableIndex(patternIndex) &&\n            input.charAt(i) === this.pattern.pattern[patternIndex]) {\n          continue\n        }\n      }\n      extend(this, initialState)\n      return false\n    }\n  }\n\n  return true\n}\n\n// History\n\nInputMask.prototype.undo = function undo() {\n  // If there is no history, or nothing more on the history stack, we can't undo\n  if (this._history.length === 0 || this._historyIndex === 0) {\n    return false\n  }\n\n  var historyItem\n  if (this._historyIndex == null) {\n    // Not currently undoing, set up the initial history index\n    this._historyIndex = this._history.length - 1\n    historyItem = this._history[this._historyIndex]\n    // Add a new history entry if anything has changed since the last one, so we\n    // can redo back to the initial state we started undoing from.\n    var value = this.getValue()\n    if (historyItem.value !== value ||\n        historyItem.selection.start !== this.selection.start ||\n        historyItem.selection.end !== this.selection.end) {\n      this._history.push({value: value, selection: copy(this.selection), lastOp: this._lastOp, startUndo: true})\n    }\n  }\n  else {\n    historyItem = this._history[--this._historyIndex]\n  }\n\n  this.value = historyItem.value.split('')\n  this.selection = historyItem.selection\n  this._lastOp = historyItem.lastOp\n  return true\n}\n\nInputMask.prototype.redo = function redo() {\n  if (this._history.length === 0 || this._historyIndex == null) {\n    return false\n  }\n  var historyItem = this._history[++this._historyIndex]\n  // If this is the last history item, we're done redoing\n  if (this._historyIndex === this._history.length - 1) {\n    this._historyIndex = null\n    // If the last history item was only added to start undoing, remove it\n    if (historyItem.startUndo) {\n      this._history.pop()\n    }\n  }\n  this.value = historyItem.value.split('')\n  this.selection = historyItem.selection\n  this._lastOp = historyItem.lastOp\n  return true\n}\n\n// Getters & setters\n\nInputMask.prototype.setPattern = function setPattern(pattern, options) {\n  options = extend({\n    selection: {start: 0, end: 0},\n    value: ''\n  }, options)\n  this.pattern = new Pattern(pattern, this.formatCharacters, this.placeholderChar, options.isRevealingMask)\n  this.setValue(options.value)\n  this.emptyValue = this.pattern.formatValue([]).join('')\n  this.selection = options.selection\n  this._resetHistory()\n}\n\nInputMask.prototype.setSelection = function setSelection(selection) {\n  this.selection = copy(selection)\n  if (this.selection.start === this.selection.end) {\n    if (this.selection.start < this.pattern.firstEditableIndex) {\n      this.selection.start = this.selection.end = this.pattern.firstEditableIndex\n      return true\n    }\n    // Set selection to the first editable, non-placeholder character before the selection\n    // OR to the beginning of the pattern\n    var index = this.selection.start\n    while (index >= this.pattern.firstEditableIndex) {\n      if (this.pattern.isEditableIndex(index - 1) &&\n          this.value[index - 1] !== this.placeholderChar ||\n          index === this.pattern.firstEditableIndex) {\n        this.selection.start = this.selection.end = index\n        break\n      }\n      index--\n    }\n    return true\n  }\n  return false\n}\n\nInputMask.prototype.setValue = function setValue(value) {\n  if (value == null) {\n    value = ''\n  }\n  this.value = this.pattern.formatValue(value.split(''))\n}\n\nInputMask.prototype.getValue = function getValue() {\n  return this.value.join('')\n}\n\nInputMask.prototype.getRawValue = function getRawValue() {\n  var rawValue = []\n  for (var i = 0; i < this.value.length; i++) {\n    if (this.pattern._editableIndices[i] === true) {\n      rawValue.push(this.value[i])\n    }\n  }\n  return rawValue.join('')\n}\n\nInputMask.prototype._resetHistory = function _resetHistory() {\n  this._history = []\n  this._historyIndex = null\n  this._lastOp = null\n  this._lastSelection = copy(this.selection)\n}\n\nInputMask.Pattern = Pattern\n\nmodule.exports = InputMask\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/inputmask-core/lib/index.js\n// module id = 1\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}